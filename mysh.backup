#include "mysh.h"

extern sigset_t fullset;
extern PIDTABLE *ptable;
extern COMMAND *cmd;
extern PROCGROUP *foreground;
extern int ttyd;


/* Function: shell_pwd
   print current directory
*/
int shell_pwd()
{
	int size;
	char *p = NULL;

	for (size = INTERNAL_BUF; ; size += INTERNAL_BUF)
	{
		char buf[size];
		p = getcwd((char*)&buf, size);
		if (p == NULL && errno == ERANGE)
		{
			continue;
		}
		printf("%s", p);
		break;
	}

	return 0;
}


/* Function: shell_cd
   change current working directory
*/
int shell_cd(const char *path)
{
	if (path == NULL)
	{
		return 0;
	}

	if (chdir(path) == -1)
	{
		printf("-mysh: cd %s: ", path);
		fflush(stdout);
		perror("");
	}

	return 0;
}


/* Function
*/
int shell_atoi(const char *s)
{
	if (s != NULL && *s++ == '%')
	{
		return atoi(s);
	}
	else
	{
		return -1;
	}
}


/* Function: shell_run
   Handles all shell built-ins
*/
int shell_run(const char *cmd, const char *arg, PIDTABLE *ptable, int ttyd)
{
	int table_id = shell_atoi(arg);
	PROCGROUP *pgrp = NULL;

	if (cmd == NULL)
	{
		// no command
		return MYSH_NEXT;
	}

	else if (strncmp(cmd, "jobs", 4) == 0)
	{
		pidtable_print(ptable);
	}

	else if (strncmp(cmd, "exit", 4) == 0)
	{
		return MYSH_EXIT;
	}

	else if (strncmp(cmd, "kill", 4) == 0)
	{
		pgrp = (PROCGROUP*) pidtable_getindex(ptable, table_id);
		if (pgrp == NULL)
		{
#ifdef WARNING
	printf("-mysh: kill: %s: no such job\n", arg);
#endif
		}
		else
		{
			kill(pgrp->group_pid, SIGKILL);
		}
	}

	else if (strncmp(cmd, "pwd", 3) == 0)
	{
		shell_pwd();
		printf("\n");
	}

	else if (strncmp(cmd, "cd", 2) == 0)
	{
		shell_cd(arg);
	}

	else if (strncmp(cmd, "bg", 2) == 0)
	{
		pgrp = (PROCGROUP*) pidtable_getindex(ptable, table_id);
		if (pgrp == NULL)
		{
#ifdef WARNING
	printf("-mysh: bg: %s: no such job\n", arg);
#endif
		}
		else
		{
			kill(pgrp->group_pid, SIGCONT);
		}
	}

	else if (strncmp(cmd, "fg", 2) == 0)
	{
		pgrp = (PROCGROUP*) pidtable_getindex(ptable, table_id);
		if (pgrp == NULL)
		{
#ifdef WARNING
	printf("-mysh: fg: %s: no such job\n", arg);
#endif
		}
		else
		{
			//pidtable_delpid(ptable, pgrp->group_pid, FALSE);
			kill(pgrp->group_pid, SIGCONT);
			pid_t gid = getpgid(pgrp->group_pid);
			tcsetpgrp(ttyd, gid);
			int wait_id = -1;
			while(wait_id == -1)
			{
				wait_id = waitpid(- gid, NULL, WUNTRACED|WCONTINUED);
			}
			tcsetpgrp(ttyd, getpid());
		}
	}

	else
	{
		// Not a built-in command
		return MYSH_EXTC;
	}

	return MYSH_NEXT;
}


/* Function: print_debug
   Prints out colored debugging text
*/
void print_debug(const char *s)
{
#ifdef DEBUG
	printf("%s%s%s\n", MYSH_RED, s, MYSH_GRAY);
	fflush(stdout);
#endif
}


/* Function: sighandler
*/
void sighandler(int signum, siginfo_t *si, void *context)
{

	int cldpid = si->si_pid;
	PROCGROUP *cldgrp = NULL;

	// Critical Section: block signal
	sigprocmask(SIG_SETMASK, &fullset, NULL);
	switch(signum)
	{
		// need to kill foreground process
		case SIGINT:
			break;

		// dont know
		case SIGQUIT:
			break;

		// CTRL-Z
		case SIGTSTP:
			break;

		// Child process signal
		case SIGCHLD:
			switch(si->si_code)
			{
				case CLD_EXITED:
					if (cldpid == tcgetpgrp(ttyd))
						pidtable_delpid(ptable, cldpid, FALSE);
					else
						pidtable_delpid(ptable, cldpid, TRUE);
					break;

				case CLD_KILLED:
					pidtable_delpid(ptable, cldpid, TRUE);
					break;

				case CLD_STOPPED:
					cldgrp = (PROCGROUP*) pidtable_getpid(ptable, cldpid);
					if (cldgrp != NULL)
					{
						cldgrp->status = STOPPED;
					}
					else
					{
						int pgid;
						pgid = tcgetpgrp(ttyd);
						if (pgid != getpid())
						{
							foreground->status = STOPPED;
							int table_id = pidtable_add(ptable, foreground);
							printf("[%d] %d\n", table_id, pgid);
							kill(pgid, SIGSTOP);
						}
						tcsetpgrp(ttyd, getpid());
					}
					break;

				case CLD_CONTINUED:
					cldgrp = (PROCGROUP*) pidtable_getpid(ptable, cldpid);
					if (cldgrp != NULL)
					{
						cldgrp->status = RUNNING;
					}
					break;

				default: break;
			}
	}
	sigprocmask(SIG_UNBLOCK, &fullset, NULL);
	// End critical

}


/* Function: pipe_command
   piping
*/
/*
int pipe_command(const COMMAND *cmp)
{
	print_debug("DEBUG: Begin piping");

	int pipefd[2] = {0,1}, pipefd_old[2] = {0,1};
	int pidn, fd, ret = 0, location = 0, wait_id = -1;
	int gpid = 0;

pipe_loop:
	if (cmp->next == NULL)
	{
		goto pipe_last;
	}

	pipefd_old[0] = pipefd[0];
	pipefd_old[1] = pipefd[1];
	if (pipe(pipefd) == -1)
	{
#ifdef WARNING
		perror("pipe");
#endif
		return -1;
	}

	// Child 
	if ((pidn = fork()) == 0)
	{
		if (current_pid == 0)
		{
			current_pid = getpid();
			setpgid(getpid(), getpid());
		}
		else
		{
			setpgid(getpid(), current_pid);
		}

		printf("set %d to foreground\n", current_pid);
//		tcsetpgrp(ttyd, current_pid);

#ifdef DEBUG
	printf("New child %d in group %d\n", getpid(), getpgid(getpid()));
#endif
		
		// Input redirect
		if (cmp->infile != NULL)
		{
			print_debug("DEBUG: Setting input file");
			fd = open(cmp->infile, cmp->fdmode);
			dup2(fd, 0);
			close(fd);
		}

		if (location != 0)
		{
			dup2(pipefd_old[0], 0);
			close(pipefd_old[0]);
			close(pipefd_old[1]);
		}

		dup2(pipefd[1], 1);
		close(pipefd[0]);
		close(pipefd[1]);

		if (execvp(cmp->argv[0], cmp->argv) == -1)
		{
			_exit(0);
		}
	}
	// Parent, close old pipes
	else{
		if (current_pid == 0)
		{
			current_pid = pidn;
		}
		setpgid(pidn, current_pid);

		printf("set %d to foreground\n", current_pid);
		tcsetpgrp(ttyd, current_pid);

		if (location++ != 0)
		{
			close(pipefd_old[0]);
			close(pipefd_old[1]);
		}

		cmp = cmp->next;
		if (cmp->pipe == TRUE)
			goto pipe_loop;
	}


pipe_last:

	if ((pidn = fork()) == 0)	
	{
		setpgid(getpid(), current_pid);
#ifdef DEBUG
	printf("Last New child %d in group %d\n", getpid(), getpgid(getpid()));
#endif

		// Output redirect
		if (cmp->outfile != NULL)
		{
			print_debug("DEBUG: Setting output file");
			fd = open(cmp->outfile, cmp->fdmode);
			if (fd == -1)
			{
				// File does not exists, create 
				fd = creat(cmp->outfile, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
			}
			dup2(fd, 1);
			close(fd);
		}

		dup2(pipefd[0], 0);
		close(pipefd[0]);
		close(pipefd[1]);

		if (execvp(cmp->argv[0], cmp->argv) == -1)
		{
			_exit(0);
		}
	}
	// Parent
	else{
		setpgid(pidn, current_pid);

		close(pipefd[0]);
		close(pipefd[1]);

		wait_id = -1;
		while(wait_id == -1)
		{
			wait_id = waitpid(pidn, NULL, WUNTRACED|WCONTINUED);
		}
		current_pid = 0;
		printf("set %d to foreground\n", getpid());
		tcsetpgrp(ttyd, getpid());
	}

	print_debug("DEBUG: End piping");

	if (cmp->next != NULL)
	{
		ret = exec_command(cmp->next);
	}

	return ret;
}
*/


/* Function: exec_command
*/
int exec_command(const COMMAND *cmp)
{
	int ret = 0, wait_id = -1, cld_pid, fd;
	
	// Built-in commands

	ret = shell_run(cmp->argv[0], cmp->argv[1], ptable, ttyd);

	switch(ret)
	{
		case MYSH_EXTC: break;
		case MYSH_NEXT: goto exec_next; break;
		case MYSH_TERM: goto exec_terminate; break;
		case MYSH_EXIT: goto exec_terminate; break;
		default: break;
	}

	cld_pid = fork();
	if (cld_pid == -1)
	{
		perror("fork");
		goto exec_terminate;
	}
	// Child
	else if (cld_pid == 0)
	{
		// Set process group
		setpgid(getpid(), getpid());

		// Set to foreground 
		if (cmp->background == FALSE)
		{
			tcsetpgrp(ttyd, getpid());
		}

#ifdef DEBUG
	printf("%s", MYSH_RED);
	printf("CHILD: New %d in group %d\n", getpid(), (int)getpgid(0));
	printf("CHILD: Set foreground group to %d\n", getpid());
	printf("%s", MYSH_GRAY); 
	fflush(stdout);
#endif

		print_debug("DEBUG: Command start -----------");

		// Input redirect
		if (cmp->infile != NULL)
		{
			print_debug("DEBUG: Setting input file");
			fd = open(cmp->infile, cmp->fdmode);
			dup2(fd, 0);
			close(fd);
		}

		// Output redirect
		if (cmp->outfile != NULL)
		{
			print_debug("DEBUG: Setting output file");
			fd = open(cmp->outfile, cmp->fdmode);
			if (fd == -1)
			{
				// File does not exists, create 
				fd = creat(cmp->outfile, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
			}
			dup2(fd, 1);
			close(fd);
		}

		// Execute command
		if (execvp(cmp->argv[0], cmp->argv) == -1)
		{
#ifdef WARNING
			switch(errno)
			{
				case ENOENT:
					printf("-mysh: %s: command not found\n", cmp->argv[0]);
					break;
				default: 
					perror("-mysh: ");
			}
#endif		
			_exit(0);
		}
	}

	// Parent	
	else if (cld_pid > 0)
	{
		// set child progress group 
		setpgid(cld_pid, cld_pid);
		procgroup_load(foreground, cld_pid, RUNNING, cmp->cmdline);

#ifdef DEBUG
	printf("%s", MYSH_RED);
	printf("PARENT: New child %d in group %d\n", cld_pid, getpgid(cld_pid));
	printf("PARENT: Set foreground group to %d\n", cld_pid);
	printf("%s", MYSH_GRAY);
#endif

		// if background
		if (cmp->background == TRUE)
		{
			sigprocmask(SIG_SETMASK, &fullset, NULL);
			int table_id = pidtable_add(ptable, foreground);
			foreground = NULL;
			sigprocmask(SIG_UNBLOCK, &fullset, NULL);
			printf("[%d] %d\n", table_id, cld_pid);
		}

		else {
			// Set to foreground
			tcsetpgrp(ttyd, cld_pid);
			// Wait for a specific PID
			while(wait_id == -1)
			{
				wait_id = waitpid(cld_pid, NULL, WUNTRACED|WCONTINUED);
			}
			print_debug("DEBUG: Command terminated  -----");
//			procgroup_free(foreground);
		}

		// Reset foreground group
		tcsetpgrp(ttyd, getpid());
		foreground = procgroup_init();

#ifdef DEBUG
	printf("%s", MYSH_RED);
	printf("PARENT: Reset foreground group to %d\n", getpid());
	printf("%s", MYSH_GRAY);
#endif

		goto exec_next;
	}

exec_next:
	if (cmp->next != NULL)
	{
		ret = exec_command((COMMAND*)cmp->next);
	}

exec_terminate:
	return ret;
}


/* MAIN */
int main()
{
	// variable and data structures
	int ret, status;
	char buffer[CMD_MAX], *read;
	ptable = pidtable_init();
	foreground = procgroup_init();
	ttyd = open("/dev/tty", O_RDWR, 0700);

	// Create set containing all signals for blocking
	sigfillset(&fullset);

	// Setup Signal Handler
	struct sigaction sa;
	sa.sa_flags |= SA_SIGINFO;
	sa.sa_sigaction = sighandler;
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGQUIT, &sa, NULL);
	sigaction(SIGCHLD, &sa, NULL);
	sigaction(SIGTSTP, &sa, NULL);
	signal(SIGTTOU, SIG_IGN);

#ifdef DEBUG
	printf("%s", MYSH_RED);
	int pgid;
	pgid = tcgetpgrp(ttyd);
	printf("DEBUG: Shell id (%d) in (%d)\n", getpid(), getpgid(getpid()));
	printf("DEBUG: Terminal Group id: %d\n", pgid);
	printf("%s", MYSH_GRAY);
#endif

	// begin main loop
	while(TRUE)
	{
		waitpid(-1, &status, WNOHANG|WCONTINUED);

		// Shell prompt	
		printf("%sMysh%s ", MYSH_LGREEN, MYSH_LBLUE);
		shell_pwd();
		printf(" #%s ", MYSH_GRAY);

		// Get input from stdin
		memset(&buffer, CMD_MAX, '\0');
		read = NULL;
		while (read == NULL)
		{
			read = fgets(buffer, CMD_MAX, stdin);
		}

		// Parse/tokenize command
		cmd = command_parse(buffer);

#ifdef DEBUG
	printf("%s", MYSH_RED);
	command_print(cmd);
	printf("%s", MYSH_GRAY);
#endif

		ret = exec_command(cmd);
		print_debug("DEBUG: Free command struct");

		// reset data structure
		command_free(cmd);

		switch (ret)
		{
			case 10: goto finalize;
			default: break;
		}
	}


finalize:
	print_debug("DEBUG: Exiting shell");
	procgroup_free(foreground);
	pidtable_free(ptable);
	return 0;
}
